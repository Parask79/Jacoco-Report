<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>HomeViewModel.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">app</a> &gt; <a href="index.source.html" class="el_package">com.example.logger.presentation.home</a> &gt; <span class="el_source">HomeViewModel.kt</span></div><h1>HomeViewModel.kt</h1><pre class="source lang-java linenums">package com.example.logger.presentation.home

import android.util.Log
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.logger.core.network.NetworkResult
import com.example.logger.core.util.DateFormatter
import com.example.logger.data.mapper.toSummary
import com.example.logger.domain.model.Standup
import com.example.logger.domain.usecase.GetTeamMembersUseCase
import com.example.logger.domain.usecase.GetTeamSentimentsUseCase
import com.example.logger.domain.usecase.GetTodayStandupUseCase
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
<span class="fc" id="L21">class HomeViewModel @Inject constructor(</span>
<span class="fc" id="L22">    private val getTodayStandup: GetTodayStandupUseCase,</span>
<span class="fc" id="L23">    private val getTeamMembers: GetTeamMembersUseCase,</span>
<span class="fc" id="L24">    private val getTeamSentiments: GetTeamSentimentsUseCase</span>
<span class="fc" id="L25">) : ViewModel() {</span>

<span class="fc" id="L27">    private val _uiState = MutableStateFlow(HomeUiState(isLoading = true))</span>
<span class="fc" id="L28">    val uiState: StateFlow&lt;HomeUiState&gt; = _uiState</span>


    // Map to store team member id to name mapping
<span class="fc" id="L32">    private val teamMembersMap = mutableMapOf&lt;Long, String&gt;()</span>

<span class="fc" id="L34">    init {</span>
<span class="fc" id="L35">        fetchTeamMembers()</span>
<span class="fc" id="L36">        loadTeamSentiments()</span>
<span class="fc" id="L37">    }</span>

    private fun fetchTeamMembers() {
<span class="fc" id="L40">        viewModelScope.launch {</span>
            getTeamMembers(1, 0, 100, true).collect { result -&gt;
                if (result is NetworkResult.Success) {
                    val members = result.data
                    // Store in map for easy lookup
                    teamMembersMap.clear()
                    members.forEach { member -&gt;
                        teamMembersMap[member.id] = member.name
                    }
                    _uiState.update { it.copy(roster = members.map { m -&gt; m.name }) }
                    // Load standup data after team members are fetched
                    load()
                }
            }
        }
<span class="fc" id="L55">    }</span>

<span class="fc" id="L57">    fun load(resetList: Boolean = true, fetchAllStandups: Boolean = false) {</span>
<span class="fc" id="L58">        viewModelScope.launch {</span>
            // Only show full loading if team members haven't been loaded yet
            val showFullLoading = teamMembersMap.isEmpty()

            if (resetList) {
                _uiState.update {
                    it.copy(
                        isLoading = showFullLoading,
                        error = null,
                        currentPage = 0
                    )
                }
            } else {
                _uiState.update { it.copy(isLoadingMore = true, error = null) }
            }

            // Get today's date in yyyy-MM-dd format (IST)
            val todayDate = DateFormatter.getCurrentDateString()
            val currentState = _uiState.value

            // If fetchAllStandups is true, use a large size to get all in one call
            val pageSize = if (fetchAllStandups) 100 else currentState.pageSize
            val page = if (fetchAllStandups) 0 else currentState.currentPage

            val result = getTodayStandup(
                teamId = 1, // Using hardcoded teamId for now
                page = page,
                size = pageSize,
                standupDate = todayDate
            )

            when (result) {
                is NetworkResult.Success -&gt; {
                    val data = result.data
                    val updatedEntries = if (resetList) {
                        data.items
                    } else {
                        currentState.standupEntries + data.items
                    }

                    // Map StandupEntryData to Standup model for UI
                    // createdAt and updatedAt are already formatted to time strings (HH:mm) in the mapper
                    // Use teamMember.name from API response if available, fallback to teamMembersMap or ID
                    val mappedSubmissions = updatedEntries.map { entry -&gt;
                        val memberName = entry.teamMember?.name
                            ?: teamMembersMap[entry.teamMemberId]
                            ?: &quot;Team Member #${entry.teamMemberId}&quot;
                        val time = entry.createdAt ?: &quot;--:--&quot;

                        Standup(
                            id = entry.id.toString(),
                            name = memberName,
                            yesterday = entry.yesterdayWork!!,
                            today = entry.todayPlan!!,
                            blockers = entry.blockers,
                            time = time,
                            editedAt = entry.updatedAt
                        )
                    }

                    // Calculate pending members based on total count, not loaded items
                    // This ensures correct count during pagination
                    val totalSubmitted = data.meta.totalElements
                    val totalTeamMembers = teamMembersMap.size
                    val pendingCount = totalTeamMembers - totalSubmitted

                    // For the pending list, calculate based on ALL loaded entries across pagination
                    // This gives us an accurate list of who hasn't submitted based on what we've loaded so far
                    val submittedMemberIds = updatedEntries.map { it.teamMemberId }.toSet()
                    val pendingMembers = teamMembersMap.filterKeys { it !in submittedMemberIds }.values.toList()

                    _uiState.update {
                        it.copy(
                            isLoading = false,
                            isLoadingMore = false,
                            error = null,
                            date = todayDate,
                            submissions = mappedSubmissions,
                            pending = pendingMembers, // Names list (from loaded data)
                            pendingCount = pendingCount, // Accurate count (from totalElements)
                            lastUpdated = nowTime(),
                            standupEntries = updatedEntries,
                            currentPage = data.meta.page,
                            totalEntries = data.meta.totalElements,
                            totalPages = data.meta.totalPages,
                            canLoadMore = data.meta.page &lt; data.meta.totalPages - 1
                        )
                    }
                }

                is NetworkResult.Error -&gt; _uiState.update {
                    it.copy(
                        isLoading = false,
                        isLoadingMore = false,
                        error = result.message ?: &quot;Unknown error&quot;
                    )
                }
            }
        }
<span class="fc" id="L157">    }</span>

    fun loadMore() {
<span class="fc" id="L160">        val currentState = _uiState.value</span>
<span class="pc bpc" id="L161" title="2 of 4 branches missed.">        if (currentState.canLoadMore &amp;&amp; !currentState.isLoadingMore) {</span>
<span class="fc" id="L162">            _uiState.update { it.copy(currentPage = currentState.currentPage + 1) }</span>
<span class="fc" id="L163">            load(resetList = false)</span>
        }
<span class="fc" id="L165">    }</span>

    private fun loadTeamSentiments() {
<span class="fc" id="L168">        viewModelScope.launch {</span>
            _uiState.update { it.copy(isSentimentLoading = true, sentimentError = null) }

            // Compute 30-day range in IST: from = today - 30 days, to = today
            val toDate = DateFormatter.getCurrentDateString()
            val fromDate = DateFormatter.getDateDaysAgoString(30)

            getTeamSentiments(
                teamId = 1, // Using hardcoded teamId for now
                from = fromDate,
                to = toDate
            ).collect { result -&gt;
                when (result) {
                    is NetworkResult.Success -&gt; {
                        val summary = result.data.toSummary()
                        _uiState.update {
                            it.copy(
                                sentimentSummary = summary,
                                isSentimentLoading = false,
                                sentimentError = null
                            )
                        }
                    }
                    is NetworkResult.Error -&gt; {
                        _uiState.update {
                            it.copy(
                                isSentimentLoading = false,
                                sentimentError = result.message
                            )
                        }
                    }
                }
            }
        }
<span class="fc" id="L202">    }</span>

<span class="fc" id="L204">    private fun nowTime(): String = DateFormatter.getCurrentTimeString()</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>